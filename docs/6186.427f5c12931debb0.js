"use strict";(self.webpackChunkapp=self.webpackChunkapp||[]).push([[6186],{6186:(Wn,fe,qt)=>{qt.r(fe),qt.d(fe,{encodeToCurve:()=>Yn,hashToCurve:()=>Gn,schnorr:()=>Mn,secp256k1:()=>Zt,secp256k1_hasher:()=>ce});var x=qt(4122);function Je(t,e,r){return t&e^~t&r}function Fe(t,e,r){return t&e^t&r^e&r}class ae extends x.Vw{constructor(e,r,n,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=r,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(e),this.view=(0,x.O8)(this.buffer)}update(e){(0,x.CC)(this),e=(0,x.ZJ)(e),(0,x.DO)(e);const{view:r,buffer:n,blockLen:s}=this,o=e.length;for(let i=0;i<o;){const c=Math.min(s-this.pos,o-i);if(c===s){const f=(0,x.O8)(e);for(;s<=o-i;i+=s)this.process(f,i);continue}n.set(e.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===s&&(this.process(r,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){(0,x.CC)(this),(0,x.Ht)(e,this),this.finished=!0;const{buffer:r,view:n,blockLen:s,isLE:o}=this;let{pos:i}=this;r[i++]=128,(0,x.uH)(this.buffer.subarray(i)),this.padOffset>s-i&&(this.process(n,0),i=0);for(let h=i;h<s;h++)r[h]=0;(function Qe(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const s=BigInt(32),o=BigInt(4294967295),i=Number(r>>s&o),c=Number(r&o),u=n?0:4;t.setUint32(e+(n?4:0),i,n),t.setUint32(e+u,c,n)})(n,s-8,BigInt(8*this.length),o),this.process(n,0);const c=(0,x.O8)(e),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=f/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<u;h++)c.setUint32(4*h,l[h],o)}digest(){const{buffer:e,outputLen:r}=this;this.digestInto(e);const n=e.slice(0,r);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:r,buffer:n,length:s,finished:o,destroyed:i,pos:c}=this;return e.destroyed=i,e.finished=o,e.length=s,e.pos=c,s%r&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const at=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var q=qt(6555);const tn=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ut=new Uint32Array(64);class de extends ae{constructor(e=32){super(64,e,8,!1),this.A=0|at[0],this.B=0|at[1],this.C=0|at[2],this.D=0|at[3],this.E=0|at[4],this.F=0|at[5],this.G=0|at[6],this.H=0|at[7]}get(){const{A:e,B:r,C:n,D:s,E:o,F:i,G:c,H:f}=this;return[e,r,n,s,o,i,c,f]}set(e,r,n,s,o,i,c,f){this.A=0|e,this.B=0|r,this.C=0|n,this.D=0|s,this.E=0|o,this.F=0|i,this.G=0|c,this.H=0|f}process(e,r){for(let h=0;h<16;h++,r+=4)ut[h]=e.getUint32(r,!1);for(let h=16;h<64;h++){const a=ut[h-15],d=ut[h-2],w=(0,x.Ow)(a,7)^(0,x.Ow)(a,18)^a>>>3,y=(0,x.Ow)(d,17)^(0,x.Ow)(d,19)^d>>>10;ut[h]=y+ut[h-7]+w+ut[h-16]|0}let{A:n,B:s,C:o,D:i,E:c,F:f,G:u,H:l}=this;for(let h=0;h<64;h++){const d=l+((0,x.Ow)(c,6)^(0,x.Ow)(c,11)^(0,x.Ow)(c,25))+Je(c,f,u)+tn[h]+ut[h]|0,y=((0,x.Ow)(n,2)^(0,x.Ow)(n,13)^(0,x.Ow)(n,22))+Fe(n,s,o)|0;l=u,u=f,f=c,c=i+d|0,i=o,o=s,s=n,n=d+y|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,c=c+this.E|0,f=f+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,s,o,i,c,f,u,l)}roundClean(){(0,x.uH)(ut)}destroy(){this.set(0,0,0,0,0,0,0,0),(0,x.uH)(this.buffer)}}q.lD(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t)));const Rt=(0,x.qj)(()=>new de);class le extends x.Vw{constructor(e,r){super(),this.finished=!1,this.destroyed=!1,(0,x.sd)(e);const n=(0,x.ZJ)(r);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(n.length>s?e.create().update(n).digest():n);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=e.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),(0,x.uH)(o)}update(e){return(0,x.CC)(this),this.iHash.update(e),this}digestInto(e){(0,x.CC)(this),(0,x.DO)(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:n,finished:s,destroyed:o,blockLen:i,outputLen:c}=this;return e.finished=s,e.destroyed=o,e.blockLen=i,e.outputLen=c,e.oHash=r._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const he=(t,e,r)=>new le(t,e).update(r).digest();he.create=(t,e)=>new le(t,e);const Ct=BigInt(0),St=BigInt(1);function Ut(t,e=""){if("boolean"!=typeof t)throw new Error((e&&`"${e}"`)+"expected boolean, got type="+typeof t);return t}function wt(t,e,r=""){const n=(0,x.aY)(t),s=t?.length,o=void 0!==e;if(!n||o&&s!==e)throw new Error((r&&`"${r}" `)+"expected Uint8Array"+(o?` of length ${e}`:"")+", got "+(n?`length=${s}`:"type="+typeof t));return t}function At(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function be(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?Ct:BigInt("0x"+t)}function mt(t){return be((0,x.My)(t))}function ge(t){return(0,x.DO)(t),be((0,x.My)(Uint8Array.from(t).reverse()))}function Nt(t,e){return(0,x.aT)(t.toString(16).padStart(2*e,"0"))}function we(t,e){return Nt(t,e).reverse()}function K(t,e,r){let n;if("string"==typeof e)try{n=(0,x.aT)(e)}catch(o){throw new Error(t+" must be hex string or Uint8Array, cause: "+o)}else{if(!(0,x.aY)(e))throw new Error(t+" must be hex string or Uint8Array");n=Uint8Array.from(e)}const s=n.length;if("number"==typeof r&&s!==r)throw new Error(t+" of length "+r+" expected, got "+s);return n}const Kt=t=>"bigint"==typeof t&&Ct<=t;function jt(t,e,r){return Kt(t)&&Kt(e)&&Kt(r)&&e<=t&&t<r}function me(t){let e;for(e=0;t>Ct;t>>=St,e+=1);return e}const It=t=>(St<<BigInt(t))-St;function Tt(t,e,r={}){if(!t||"object"!=typeof t)throw new Error("expected valid options object");function n(s,o,i){const c=t[s];if(i&&void 0===c)return;const f=typeof c;if(f!==o||null===c)throw new Error(`param "${s}" is invalid: expected ${o}, got ${f}`)}Object.entries(e).forEach(([s,o])=>n(s,o,!1)),Object.entries(r).forEach(([s,o])=>n(s,o,!0))}function xe(t){const e=new WeakMap;return(r,...n)=>{const s=e.get(r);if(void 0!==s)return s;const o=t(r,...n);return e.set(r,o),o}}const J=BigInt(0),M=BigInt(1),xt=BigInt(2),ye=BigInt(3),Ee=BigInt(4),pe=BigInt(5),fn=BigInt(7),Be=BigInt(8),an=BigInt(9),ve=BigInt(16);function F(t,e){const r=t%e;return r>=J?r:e+r}function nt(t,e,r){let n=t;for(;e-- >J;)n*=n,n%=r;return n}function Gt(t,e){if(t===J)throw new Error("invert: expected non-zero number");if(e<=J)throw new Error("invert: expected positive modulus, got "+e);let r=F(t,e),n=e,s=J,o=M,i=M,c=J;for(;r!==J;){const u=n/r,l=n%r,h=s-i*u,a=o-c*u;n=r,r=l,s=i,o=c,i=h,c=a}if(n!==M)throw new Error("invert: does not exist");return F(s,e)}function Yt(t,e,r){if(!t.eql(t.sqr(e),r))throw new Error("Cannot find square root")}function _e(t,e){const n=t.pow(e,(t.ORDER+M)/Ee);return Yt(t,n,e),n}function dn(t,e){const r=(t.ORDER-pe)/Be,n=t.mul(e,xt),s=t.pow(n,r),o=t.mul(e,s),i=t.mul(t.mul(o,xt),s),c=t.mul(o,t.sub(i,t.ONE));return Yt(t,c,e),c}function Se(t){if(t<ye)throw new Error("sqrt is not defined for small field");let e=t-M,r=0;for(;e%xt===J;)e/=xt,r++;let n=xt;const s=Et(t);for(;1===Wt(s,n);)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===r)return _e;let o=s.pow(n,e);const i=(e+M)/xt;return function(f,u){if(f.is0(u))return u;if(1!==Wt(f,u))throw new Error("Cannot find square root");let l=r,h=f.mul(f.ONE,o),a=f.pow(u,e),d=f.pow(u,i);for(;!f.eql(a,f.ONE);){if(f.is0(a))return f.ZERO;let w=1,y=f.sqr(a);for(;!f.eql(y,f.ONE);)if(w++,y=f.sqr(y),w===l)throw new Error("Cannot find square root");const B=M<<BigInt(l-w-1),O=f.pow(h,B);l=w,h=f.sqr(O),a=f.mul(a,h),d=f.mul(d,O)}return d}}const hn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ae(t){return Tt(t,hn.reduce((n,s)=>(n[s]="function",n),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"})),t}function Lt(t,e,r=!1){const n=new Array(e.length).fill(r?t.ZERO:void 0),s=e.reduce((i,c,f)=>t.is0(c)?i:(n[f]=i,t.mul(i,c)),t.ONE),o=t.inv(s);return e.reduceRight((i,c,f)=>t.is0(c)?i:(n[f]=t.mul(i,n[f]),t.mul(i,c)),o),n}function Wt(t,e){const n=t.pow(e,(t.ORDER-M)/xt),s=t.eql(n,t.ONE),o=t.eql(n,t.ZERO),i=t.eql(n,t.neg(t.ONE));if(!s&&!o&&!i)throw new Error("invalid Legendre symbol result");return s?1:o?0:-1}function zt(t,e){void 0!==e&&(0,x.Fe)(e);const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Et(t,e,r=!1,n={}){if(t<=J)throw new Error("invalid field: expected ORDER > 0, got "+t);let s,o,c,i=!1;if("object"==typeof e&&null!=e){if(n.sqrt||r)throw new Error("cannot specify opts in two arguments");e.BITS&&(s=e.BITS),e.sqrt&&(o=e.sqrt),"boolean"==typeof e.isLE&&(r=e.isLE),"boolean"==typeof e.modFromBytes&&(i=e.modFromBytes),c=e.allowedLengths}else"number"==typeof e&&(s=e),n.sqrt&&(o=n.sqrt);const{nBitLength:f,nByteLength:u}=zt(t,s);if(u>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let l;const h=Object.freeze({ORDER:t,isLE:r,BITS:f,BYTES:u,MASK:It(f),ZERO:J,ONE:M,allowedLengths:c,create:a=>F(a,t),isValid:a=>{if("bigint"!=typeof a)throw new Error("invalid field element: expected bigint, got "+typeof a);return J<=a&&a<t},is0:a=>a===J,isValidNot0:a=>!h.is0(a)&&h.isValid(a),isOdd:a=>(a&M)===M,neg:a=>F(-a,t),eql:(a,d)=>a===d,sqr:a=>F(a*a,t),add:(a,d)=>F(a+d,t),sub:(a,d)=>F(a-d,t),mul:(a,d)=>F(a*d,t),pow:(a,d)=>function Ie(t,e,r){if(r<J)throw new Error("invalid exponent, negatives unsupported");if(r===J)return t.ONE;if(r===M)return e;let n=t.ONE,s=e;for(;r>J;)r&M&&(n=t.mul(n,s)),s=t.sqr(s),r>>=M;return n}(h,a,d),div:(a,d)=>F(a*Gt(d,t),t),sqrN:a=>a*a,addN:(a,d)=>a+d,subN:(a,d)=>a-d,mulN:(a,d)=>a*d,inv:a=>Gt(a,t),sqrt:o||(a=>(l||(l=function ln(t){return t%Ee===ye?_e:t%Be===pe?dn:t%ve===an?function un(t){const e=Et(t),r=Se(t),n=r(e,e.neg(e.ONE)),s=r(e,n),o=r(e,e.neg(n)),i=(t+fn)/ve;return(c,f)=>{let u=c.pow(f,i),l=c.mul(u,n);const h=c.mul(u,s),a=c.mul(u,o),d=c.eql(c.sqr(l),f),w=c.eql(c.sqr(h),f);u=c.cmov(u,l,d),l=c.cmov(a,h,w);const y=c.eql(c.sqr(l),f),B=c.cmov(u,l,y);return Yt(c,B,f),B}}(t):Se(t)}(t)),l(h,a))),toBytes:a=>r?we(a,u):Nt(a,u),fromBytes:(a,d=!0)=>{if(c){if(!c.includes(a.length)||a.length>u)throw new Error("Field.fromBytes: expected "+c+" bytes, got "+a.length);const y=new Uint8Array(u);y.set(a,r?0:y.length-a.length),a=y}if(a.length!==u)throw new Error("Field.fromBytes: expected "+u+" bytes, got "+a.length);let w=r?ge(a):mt(a);if(i&&(w=F(w,t)),!d&&!h.isValid(w))throw new Error("invalid field element: outside of range 0..ORDER");return w},invertBatch:a=>Lt(h,a),cmov:(a,d,w)=>w?d:a});return Object.freeze(h)}function Oe(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function He(t){const e=Oe(t);return e+Math.ceil(e/2)}function qe(t,e,r=!1){const n=t.length,s=Oe(e),o=He(e);if(n<16||n<o||n>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+n);const c=F(r?ge(t):mt(t),e-M)+M;return r?we(c,s):Nt(c,s)}const pt=BigInt(0),yt=BigInt(1);function Vt(t,e){const r=e.negate();return t?r:e}function Pt(t,e){const r=Lt(t.Fp,e.map(n=>n.Z));return e.map((n,s)=>t.fromAffine(n.toAffine(r[s])))}function Xt(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function $t(t,e){Xt(t,e);const s=2**t;return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1),mask:It(t),maxNumber:s,shiftBy:BigInt(t)}}function Re(t,e,r){const{windowSize:n,mask:s,maxNumber:o,shiftBy:i}=r;let c=Number(t&s),f=t>>i;c>n&&(c-=o,f+=yt);const u=e*n;return{nextN:f,offset:u+Math.abs(c)-1,isZero:0===c,isNeg:c<0,isNegF:e%2!=0,offsetF:u}}const Qt=new WeakMap,Ne=new WeakMap;function Jt(t){return Ne.get(t)||1}function Te(t){if(t!==pt)throw new Error("invalid wNAF")}class bn{constructor(e,r){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=r}_unsafeLadder(e,r,n=this.ZERO){let s=e;for(;r>pt;)r&yt&&(n=n.add(s)),s=s.double(),r>>=yt;return n}precomputeWindow(e,r){const{windows:n,windowSize:s}=$t(r,this.bits),o=[];let i=e,c=i;for(let f=0;f<n;f++){c=i,o.push(c);for(let u=1;u<s;u++)c=c.add(i),o.push(c);i=c.double()}return o}wNAF(e,r,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let s=this.ZERO,o=this.BASE;const i=$t(e,this.bits);for(let c=0;c<i.windows;c++){const{nextN:f,offset:u,isZero:l,isNeg:h,isNegF:a,offsetF:d}=Re(n,c,i);n=f,l?o=o.add(Vt(a,r[d])):s=s.add(Vt(h,r[u]))}return Te(n),{p:s,f:o}}wNAFUnsafe(e,r,n,s=this.ZERO){const o=$t(e,this.bits);for(let i=0;i<o.windows&&n!==pt;i++){const{nextN:c,offset:f,isZero:u,isNeg:l}=Re(n,i,o);if(n=c,!u){const h=r[f];s=s.add(l?h.negate():h)}}return Te(n),s}getPrecomputes(e,r,n){let s=Qt.get(r);return s||(s=this.precomputeWindow(r,e),1!==e&&("function"==typeof n&&(s=n(s)),Qt.set(r,s))),s}cached(e,r,n){const s=Jt(e);return this.wNAF(s,this.getPrecomputes(s,e,n),r)}unsafe(e,r,n,s){const o=Jt(e);return 1===o?this._unsafeLadder(e,r,s):this.wNAFUnsafe(o,this.getPrecomputes(o,e,n),r,s)}createCache(e,r){Xt(r,this.bits),Ne.set(e,r),Qt.delete(e)}hasCache(e){return 1!==Jt(e)}}function Le(t,e,r){if(e){if(e.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Ae(e),e}return Et(t,{isLE:r})}const Ve=(t,e)=>(t+(t>=0?e:-e)/ot)/e;function Ft(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function te(t,e){const r={};for(let n of Object.keys(e))r[n]=void 0===t[n]?e[n]:t[n];return Ut(r.lowS,"lowS"),Ut(r.prehash,"prehash"),void 0!==r.format&&Ft(r.format),r}class yn extends Error{constructor(e=""){super(e)}}const it={Err:yn,_tlv:{encode:(t,e)=>{const{Err:r}=it;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(1&e.length)throw new r("tlv.encode: unpadded data");const n=e.length/2,s=At(n);if(s.length/2&128)throw new r("tlv.encode: long form length too big");const o=n>127?At(s.length/2|128):"";return At(t)+o+s+e},decode(t,e){const{Err:r}=it;let n=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new r("tlv.decode: wrong tlv");const s=e[n++];let i=0;if(128&s){const f=127&s;if(!f)throw new r("tlv.decode(long): indefinite length not supported");if(f>4)throw new r("tlv.decode(long): byte length is too big");const u=e.subarray(n,n+f);if(u.length!==f)throw new r("tlv.decode: length bytes not complete");if(0===u[0])throw new r("tlv.decode(long): zero leftmost byte");for(const l of u)i=i<<8|l;if(n+=f,i<128)throw new r("tlv.decode(long): not minimal encoding")}else i=s;const c=e.subarray(n,n+i);if(c.length!==i)throw new r("tlv.decode: wrong value length");return{v:c,l:e.subarray(n+i)}}},_int:{encode(t){const{Err:e}=it;if(t<rt)throw new e("integer: negative integers are not allowed");let r=At(t);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:e}=it;if(128&t[0])throw new e("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("invalid signature integer: unnecessary leading zero");return mt(t)}},toSig(t){const{Err:e,_int:r,_tlv:n}=it,s=K("signature",t),{v:o,l:i}=n.decode(48,s);if(i.length)throw new e("invalid signature: left bytes after parsing");const{v:c,l:f}=n.decode(2,o),{v:u,l}=n.decode(2,f);if(l.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(c),s:r.decode(u)}},hexFromSig(t){const{_tlv:e,_int:r}=it,n=e.encode(2,r.encode(t.r)),s=e.encode(2,r.encode(t.s));return e.encode(48,n+s)}},rt=BigInt(0),Y=BigInt(1),ot=BigInt(2),Bt=BigInt(3),ee=BigInt(4);function bt(t,e){const{BYTES:r}=t;let n;if("bigint"==typeof e)n=e;else{let s=K("private key",e);try{n=t.fromBytes(s)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof e}`)}}if(!t.isValidNot0(n))throw new Error("invalid private key: out of range [1..N-1]");return n}function Ze(t,e={}){const r=function mn(t,e,r={},n){if(void 0===n&&(n="edwards"===t),!e||"object"!=typeof e)throw new Error(`expected valid ${t} CURVE object`);for(const f of["p","n","h"]){const u=e[f];if(!("bigint"==typeof u&&u>pt))throw new Error(`CURVE.${f} must be positive bigint`)}const s=Le(e.p,r.Fp,n),o=Le(e.n,r.Fn,n),c=["Gx","Gy","a","weierstrass"===t?"b":"d"];for(const f of c)if(!s.isValid(e[f]))throw new Error(`CURVE.${f} must be valid field element of CURVE.Fp`);return{CURVE:e=Object.freeze(Object.assign({},e)),Fp:s,Fn:o}}("weierstrass",t,e),{Fp:n,Fn:s}=r;let o=r.CURVE;const{h:i,n:c}=o;Tt(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:f}=e;if(f&&(!n.is0(o.a)||"bigint"!=typeof f.beta||!Array.isArray(f.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=De(n,s);function l(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}const d=e.toBytes||function h(C,m,g){const{x:b,y:E}=m.toAffine(),v=n.toBytes(b);if(Ut(g,"isCompressed"),g){l();const I=!n.isOdd(E);return(0,x.Id)(ke(I),v)}return(0,x.Id)(Uint8Array.of(4),v,n.toBytes(E))},w=e.fromBytes||function a(C){wt(C,void 0,"Point");const{publicKey:m,publicKeyUncompressed:g}=u,b=C.length,E=C[0],v=C.subarray(1);if(b!==m||2!==E&&3!==E){if(b===g&&4===E){const I=n.BYTES,S=n.fromBytes(v.subarray(0,I)),_=n.fromBytes(v.subarray(I,2*I));if(!B(S,_))throw new Error("bad point: is not on curve");return{x:S,y:_}}throw new Error(`bad point: got length ${b}, expected compressed=${m} or uncompressed=${g}`)}{const I=n.fromBytes(v);if(!n.isValid(I))throw new Error("bad point: is not on curve, wrong x");const S=y(I);let _;try{_=n.sqrt(S)}catch(j){const L=j instanceof Error?": "+j.message:"";throw new Error("bad point: is not on curve, sqrt error"+L)}return l(),!(1&~E)!==n.isOdd(_)&&(_=n.neg(_)),{x:I,y:_}}};function y(C){const m=n.sqr(C),g=n.mul(m,C);return n.add(n.add(g,n.mul(C,o.a)),o.b)}function B(C,m){const g=n.sqr(m),b=y(C);return n.eql(g,b)}if(!B(o.Gx,o.Gy))throw new Error("bad curve params: generator point");const O=n.mul(n.pow(o.a,Bt),ee),U=n.mul(n.sqr(o.b),BigInt(27));if(n.is0(n.add(O,U)))throw new Error("bad curve params: a or b");function p(C,m,g=!1){if(!n.isValid(m)||g&&n.is0(m))throw new Error(`bad point coordinate ${C}`);return m}function T(C){if(!(C instanceof A))throw new Error("ProjectivePoint expected")}function V(C){if(!f||!f.basises)throw new Error("no endo");return function xn(t,e,r){const[[n,s],[o,i]]=e,c=Ve(i*t,r),f=Ve(-s*t,r);let u=t-c*n-f*o,l=-c*s-f*i;const h=u<rt,a=l<rt;h&&(u=-u),a&&(l=-l);const d=It(Math.ceil(me(r)/2))+Y;if(u<rt||u>=d||l<rt||l>=d)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:h,k1:u,k2neg:a,k2:l}}(C,f.basises,s.ORDER)}const $=xe((C,m)=>{const{X:g,Y:b,Z:E}=C;if(n.eql(E,n.ONE))return{x:g,y:b};const v=C.is0();null==m&&(m=v?n.ONE:n.inv(E));const I=n.mul(g,m),S=n.mul(b,m),_=n.mul(E,m);if(v)return{x:n.ZERO,y:n.ZERO};if(!n.eql(_,n.ONE))throw new Error("invZ was invalid");return{x:I,y:S}}),tt=xe(C=>{if(C.is0()){if(e.allowInfinityPoint&&!n.is0(C.Y))return;throw new Error("bad point: ZERO")}const{x:m,y:g}=C.toAffine();if(!n.isValid(m)||!n.isValid(g))throw new Error("bad point: x or y not field elements");if(!B(m,g))throw new Error("bad point: equation left != right");if(!C.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function Z(C,m,g,b,E){return g=new A(n.mul(g.X,C),g.Y,g.Z),m=Vt(b,m),g=Vt(E,g),m.add(g)}class A{constructor(m,g,b){this.X=p("x",m),this.Y=p("y",g,!0),this.Z=p("z",b),Object.freeze(this)}static CURVE(){return o}static fromAffine(m){const{x:g,y:b}=m||{};if(!m||!n.isValid(g)||!n.isValid(b))throw new Error("invalid affine point");if(m instanceof A)throw new Error("projective point not allowed");return n.is0(g)&&n.is0(b)?A.ZERO:new A(g,b,n.ONE)}static fromBytes(m){const g=A.fromAffine(w(wt(m,void 0,"point")));return g.assertValidity(),g}static fromHex(m){return A.fromBytes(K("pointHex",m))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(m=8,g=!0){return st.createCache(this,m),g||this.multiply(Bt),this}assertValidity(){tt(this)}hasEvenY(){const{y:m}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(m)}equals(m){T(m);const{X:g,Y:b,Z:E}=this,{X:v,Y:I,Z:S}=m,_=n.eql(n.mul(g,S),n.mul(v,E)),H=n.eql(n.mul(b,S),n.mul(I,E));return _&&H}negate(){return new A(this.X,n.neg(this.Y),this.Z)}double(){const{a:m,b:g}=o,b=n.mul(g,Bt),{X:E,Y:v,Z:I}=this;let S=n.ZERO,_=n.ZERO,H=n.ZERO,R=n.mul(E,E),j=n.mul(v,v),L=n.mul(I,I),N=n.mul(E,v);return N=n.add(N,N),H=n.mul(E,I),H=n.add(H,H),S=n.mul(m,H),_=n.mul(b,L),_=n.add(S,_),S=n.sub(j,_),_=n.add(j,_),_=n.mul(S,_),S=n.mul(N,S),H=n.mul(b,H),L=n.mul(m,L),N=n.sub(R,L),N=n.mul(m,N),N=n.add(N,H),H=n.add(R,R),R=n.add(H,R),R=n.add(R,L),R=n.mul(R,N),_=n.add(_,R),L=n.mul(v,I),L=n.add(L,L),R=n.mul(L,N),S=n.sub(S,R),H=n.mul(L,j),H=n.add(H,H),H=n.add(H,H),new A(S,_,H)}add(m){T(m);const{X:g,Y:b,Z:E}=this,{X:v,Y:I,Z:S}=m;let _=n.ZERO,H=n.ZERO,R=n.ZERO;const j=o.a,L=n.mul(o.b,Bt);let N=n.mul(g,v),k=n.mul(b,I),G=n.mul(E,S),et=n.add(g,b),D=n.add(v,I);et=n.mul(et,D),D=n.add(N,k),et=n.sub(et,D),D=n.add(g,E);let Q=n.add(v,S);return D=n.mul(D,Q),Q=n.add(N,G),D=n.sub(D,Q),Q=n.add(b,E),_=n.add(I,S),Q=n.mul(Q,_),_=n.add(k,G),Q=n.sub(Q,_),R=n.mul(j,D),_=n.mul(L,G),R=n.add(_,R),_=n.sub(k,R),R=n.add(k,R),H=n.mul(_,R),k=n.add(N,N),k=n.add(k,N),G=n.mul(j,G),D=n.mul(L,D),k=n.add(k,G),G=n.sub(N,G),G=n.mul(j,G),D=n.add(D,G),N=n.mul(k,D),H=n.add(H,N),N=n.mul(Q,D),_=n.mul(et,_),_=n.sub(_,N),N=n.mul(et,k),R=n.mul(Q,R),R=n.add(R,N),new A(_,H,R)}subtract(m){return this.add(m.negate())}is0(){return this.equals(A.ZERO)}multiply(m){const{endo:g}=e;if(!s.isValidNot0(m))throw new Error("invalid scalar: out of range");let b,E;const v=I=>st.cached(this,I,S=>Pt(A,S));if(g){const{k1neg:I,k1:S,k2neg:_,k2:H}=V(m),{p:R,f:j}=v(S),{p:L,f:N}=v(H);E=j.add(N),b=Z(g.beta,R,L,I,_)}else{const{p:I,f:S}=v(m);b=I,E=S}return Pt(A,[b,E])[0]}multiplyUnsafe(m){const{endo:g}=e,b=this;if(!s.isValid(m))throw new Error("invalid scalar: out of range");if(m===rt||b.is0())return A.ZERO;if(m===Y)return b;if(st.hasCache(this))return this.multiply(m);if(g){const{k1neg:E,k1:v,k2neg:I,k2:S}=V(m),{p1:_,p2:H}=function gn(t,e,r,n){let s=e,o=t.ZERO,i=t.ZERO;for(;r>pt||n>pt;)r&yt&&(o=o.add(s)),n&yt&&(i=i.add(s)),s=s.double(),r>>=yt,n>>=yt;return{p1:o,p2:i}}(A,b,v,S);return Z(g.beta,_,H,E,I)}return st.unsafe(b,m)}multiplyAndAddUnsafe(m,g,b){const E=this.multiplyUnsafe(g).add(m.multiplyUnsafe(b));return E.is0()?void 0:E}toAffine(m){return $(this,m)}isTorsionFree(){const{isTorsionFree:m}=e;return i===Y||(m?m(A,this):st.unsafe(this,c).is0())}clearCofactor(){const{clearCofactor:m}=e;return i===Y?this:m?m(A,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(m=!0){return Ut(m,"isCompressed"),this.assertValidity(),d(A,this,m)}toHex(m=!0){return(0,x.My)(this.toBytes(m))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(m=!0){return this.toBytes(m)}_setWindowSize(m){this.precompute(m)}static normalizeZ(m){return Pt(A,m)}static msm(m,g){return function wn(t,e,r,n){(function Ce(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((r,n)=>{if(!(r instanceof e))throw new Error("invalid point at index "+n)})})(r,t),function Ue(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((r,n)=>{if(!e.isValid(r))throw new Error("invalid scalar at index "+n)})}(n,e);const s=r.length,o=n.length;if(s!==o)throw new Error("arrays of points and scalars must have equal length");const i=t.ZERO,c=me(BigInt(s));let f=1;c>12?f=c-3:c>4?f=c-2:c>0&&(f=2);const u=It(f),l=new Array(Number(u)+1).fill(i);let a=i;for(let d=Math.floor((e.BITS-1)/f)*f;d>=0;d-=f){l.fill(i);for(let y=0;y<o;y++){const O=Number(n[y]>>BigInt(d)&u);l[O]=l[O].add(r[y])}let w=i;for(let y=l.length-1,B=i;y>0;y--)B=B.add(l[y]),w=w.add(B);if(a=a.add(w),0!==d)for(let y=0;y<f;y++)a=a.double()}return a}(A,s,m,g)}static fromPrivateKey(m){return A.BASE.multiply(bt(s,m))}}A.BASE=new A(o.Gx,o.Gy,n.ONE),A.ZERO=new A(n.ZERO,n.ONE,n.ZERO),A.Fp=n,A.Fn=s;const ft=s.BITS,st=new bn(A,e.endo?Math.ceil(ft/2):ft);return A.BASE.precompute(8),A}function ke(t){return Uint8Array.of(t?2:3)}function De(t,e){return{secretKey:e.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function On(t){const{CURVE:e,curveOpts:r,hash:n,ecdsaOpts:s}=function _n(t){const{CURVE:e,curveOpts:r}=function Me(t){const e={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},r=t.Fp;let n=t.allowedPrivateKeyLengths?Array.from(new Set(t.allowedPrivateKeyLengths.map(i=>Math.ceil(i/2)))):void 0;return{CURVE:e,curveOpts:{Fp:r,Fn:Et(e.n,{BITS:t.nBitLength,allowedLengths:n,modFromBytes:t.wrapPrivateKey}),allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes}}}(t);return{CURVE:e,curveOpts:r,hash:t.hash,ecdsaOpts:{hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN}}}(t);return function In(t,e){const r=e.Point;return Object.assign({},e,{ProjectivePoint:r,CURVE:Object.assign({},t,zt(r.Fn.ORDER,r.Fn.BITS))})}(t,function vn(t,e,r={}){(0,x.sd)(e),Tt(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const n=r.randomBytes||x.po,s=r.hmac||((g,...b)=>he(e,g,(0,x.Id)(...b))),{Fp:o,Fn:i}=t,{ORDER:c,BITS:f}=i,{keygen:u,getPublicKey:l,getSharedSecret:h,utils:a,lengths:d}=function Bn(t,e={}){const{Fn:r}=t,n=e.randomBytes||x.po,s=Object.assign(De(t.Fp,r),{seed:He(r.ORDER)});function o(d){try{return!!bt(r,d)}catch{return!1}}function c(d=n(s.seed)){return qe(wt(d,s.seed,"seed"),r.ORDER)}function f(d,w=!0){return t.BASE.multiply(bt(r,d)).toBytes(w)}function l(d){if("bigint"==typeof d)return!1;if(d instanceof t)return!0;const{secretKey:w,publicKey:y,publicKeyUncompressed:B}=s;if(r.allowedLengths||w===y)return;const O=K("key",d).length;return O===y||O===B}return Object.freeze({getPublicKey:f,getSharedSecret:function h(d,w,y=!0){if(!0===l(d))throw new Error("first arg must be private key");if(!1===l(w))throw new Error("second arg must be public key");const B=bt(r,d);return t.fromHex(w).multiply(B).toBytes(y)},keygen:function u(d){const w=c(d);return{secretKey:w,publicKey:f(w)}},Point:t,utils:{isValidSecretKey:o,isValidPublicKey:function i(d,w){const{publicKey:y,publicKeyUncompressed:B}=s;try{const O=d.length;return!(!0===w&&O!==y||!1===w&&O!==B||!t.fromBytes(d))}catch{return!1}},randomSecretKey:c,isValidPrivateKey:o,randomPrivateKey:c,normPrivateKeyToScalar:d=>bt(r,d),precompute:(d=8,w=t.BASE)=>w.precompute(d,!1)},lengths:s})}(t,r),w={prehash:!1,lowS:"boolean"==typeof r.lowS&&r.lowS,format:void 0,extraEntropy:!1},y="compact";function B(g){return g>c>>Y}function O(g,b){if(!i.isValidNot0(b))throw new Error(`invalid signature ${g}: out of range 1..Point.Fn.ORDER`);return b}class p{constructor(b,E,v){this.r=O("r",b),this.s=O("s",E),null!=v&&(this.recovery=v),Object.freeze(this)}static fromBytes(b,E=y){let v;if(function U(g,b){Ft(b);const E=d.signature;wt(g,"compact"===b?E:"recovered"===b?E+1:void 0,`${b} signature`)}(b,E),"der"===E){const{r:H,s:R}=it.toSig(wt(b));return new p(H,R)}"recovered"===E&&(v=b[0],E="compact",b=b.subarray(1));const I=i.BYTES,S=b.subarray(0,I),_=b.subarray(I,2*I);return new p(i.fromBytes(S),i.fromBytes(_),v)}static fromHex(b,E){return this.fromBytes((0,x.aT)(b),E)}addRecoveryBit(b){return new p(this.r,this.s,b)}recoverPublicKey(b){const E=o.ORDER,{r:v,s:I,recovery:S}=this;if(null==S||![0,1,2,3].includes(S))throw new Error("recovery id invalid");if(c*ot<E&&S>1)throw new Error("recovery id is ambiguous for h>1 curve");const H=2===S||3===S?v+c:v;if(!o.isValid(H))throw new Error("recovery id 2 or 3 invalid");const R=o.toBytes(H),j=t.fromBytes((0,x.Id)(ke(!(1&S)),R)),L=i.inv(H),N=V(K("msgHash",b)),k=i.create(-N*L),G=i.create(I*L),et=t.BASE.multiplyUnsafe(k).add(j.multiplyUnsafe(G));if(et.is0())throw new Error("point at infinify");return et.assertValidity(),et}hasHighS(){return B(this.s)}toBytes(b=y){if(Ft(b),"der"===b)return(0,x.aT)(it.hexFromSig(this));const E=i.toBytes(this.r),v=i.toBytes(this.s);if("recovered"===b){if(null==this.recovery)throw new Error("recovery bit must be present");return(0,x.Id)(Uint8Array.of(this.recovery),E,v)}return(0,x.Id)(E,v)}toHex(b){return(0,x.My)(this.toBytes(b))}assertValidity(){}static fromCompact(b){return p.fromBytes(K("sig",b),"compact")}static fromDER(b){return p.fromBytes(K("sig",b),"der")}normalizeS(){return this.hasHighS()?new p(this.r,i.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return(0,x.My)(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return(0,x.My)(this.toBytes("compact"))}}const T=r.bits2int||function(b){if(b.length>8192)throw new Error("input is too large");const E=mt(b),v=8*b.length-f;return v>0?E>>BigInt(v):E},V=r.bits2int_modN||function(b){return i.create(T(b))},$=It(f);function tt(g){return function rn(t,e,r,n){if(!jt(e,r,n))throw new Error("expected valid "+t+": "+r+" <= n < "+n+", got "+e)}("num < 2^"+f,g,rt,$),i.toBytes(g)}function Z(g,b){return wt(g,void 0,"message"),b?wt(e(g),void 0,"prehashed message"):g}return Object.freeze({keygen:u,getPublicKey:l,getSharedSecret:h,utils:a,lengths:d,Point:t,sign:function ft(g,b,E={}){g=K("message",g);const{seed:v,k2sig:I}=function A(g,b,E){if(["recovered","canonical"].some(k=>k in E))throw new Error("sign() legacy options not supported");const{lowS:v,prehash:I,extraEntropy:S}=te(E,w);g=Z(g,I);const _=V(g),H=bt(i,b),R=[tt(H),tt(_)];if(null!=S&&!1!==S){const k=!0===S?n(d.secretKey):S;R.push(K("extraEntropy",k))}const j=(0,x.Id)(...R),L=_;return{seed:j,k2sig:function N(k){const G=T(k);if(!i.isValidNot0(G))return;const et=i.inv(G),D=t.BASE.multiply(G).toAffine(),Q=i.create(D.x);if(Q===rt)return;const Dt=i.create(et*i.create(L+Q*H));if(Dt===rt)return;let Xe=(D.x===Q?0:2)|Number(D.y&Y),$e=Dt;return v&&B(Dt)&&($e=i.neg(Dt),Xe^=1),new p(Q,$e,Xe)}}}(g,b,E);return function sn(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");const n=d=>new Uint8Array(d),s=d=>Uint8Array.of(d);let o=n(t),i=n(t),c=0;const f=()=>{o.fill(1),i.fill(0),c=0},u=(...d)=>r(i,o,...d),l=(d=n(0))=>{i=u(s(0),d),o=u(),0!==d.length&&(i=u(s(1),d),o=u())},h=()=>{if(c++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const w=[];for(;d<e;){o=u();const y=o.slice();w.push(y),d+=o.length}return(0,x.Id)(...w)};return(d,w)=>{let y;for(f(),l(d);!(y=w(h()));)l();return f(),y}}(e.outputLen,i.BYTES,s)(v,I)},verify:function C(g,b,E,v={}){const{lowS:I,prehash:S,format:_}=te(v,w);if(E=K("publicKey",E),b=Z(K("message",b),S),"strict"in v)throw new Error("options.strict was renamed to lowS");const H=void 0===_?function st(g){let b;const E="string"==typeof g||(0,x.aY)(g),v=!E&&null!==g&&"object"==typeof g&&"bigint"==typeof g.r&&"bigint"==typeof g.s;if(!E&&!v)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(v)b=new p(g.r,g.s);else if(E){try{b=p.fromBytes(K("sig",g),"der")}catch(I){if(!(I instanceof it.Err))throw I}if(!b)try{b=p.fromBytes(K("sig",g),"compact")}catch{return!1}}return b||!1}(g):p.fromBytes(K("sig",g),_);if(!1===H)return!1;try{const R=t.fromBytes(E);if(I&&H.hasHighS())return!1;const{r:j,s:L}=H,N=V(b),k=i.inv(L),G=i.create(N*k),et=i.create(j*k),D=t.BASE.multiplyUnsafe(G).add(R.multiplyUnsafe(et));return!D.is0()&&i.create(D.x)===j}catch{return!1}},recoverPublicKey:function m(g,b,E={}){const{prehash:v}=te(E,w);return b=Z(b,v),p.fromBytes(g,"recovered").recoverPublicKey(b).toBytes()},Signature:p,hash:e})}(Ze(e,r),n,s))}const qn=mt;function gt(t,e){if(Ot(t),Ot(e),t<0||t>=1<<8*e)throw new Error("invalid I2OSP input: "+t);const r=Array.from({length:e}).fill(0);for(let n=e-1;n>=0;n--)r[n]=255&t,t>>>=8;return new Uint8Array(r)}function Rn(t,e){const r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t[n]^e[n];return r}function Ot(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Ke(t){if(!(0,x.aY)(t)&&"string"!=typeof t)throw new Error("DST must be Uint8Array or string");return"string"==typeof t?(0,x.AI)(t):t}function ne(t,e,r){Tt(r,{p:"bigint",m:"number",k:"number",hash:"function"});const{p:n,k:s,m:o,hash:i,expand:c,DST:f}=r;if(!function cn(t){return"function"==typeof t&&Number.isSafeInteger(t.outputLen)}(r.hash))throw new Error("expected valid hash");(0,x.DO)(t),Ot(e);const u=n.toString(2).length,l=Math.ceil((u+s)/8),h=e*o*l;let a;if("xmd"===c)a=function Cn(t,e,r,n){(0,x.DO)(t),Ot(r),(e=Ke(e)).length>255&&(e=n((0,x.Id)((0,x.AI)("H2C-OVERSIZE-DST-"),e)));const{outputLen:s,blockLen:o}=n,i=Math.ceil(r/s);if(r>65535||i>255)throw new Error("expand_message_xmd: invalid lenInBytes");const c=(0,x.Id)(e,gt(e.length,1)),f=gt(0,o),u=gt(r,2),l=new Array(i),h=n((0,x.Id)(f,t,u,gt(0,1),c));l[0]=n((0,x.Id)(h,gt(1,1),c));for(let d=1;d<=i;d++){const w=[Rn(h,l[d-1]),gt(d+1,1),c];l[d]=n((0,x.Id)(...w))}return(0,x.Id)(...l).slice(0,r)}(t,f,h,i);else if("xof"===c)a=function Un(t,e,r,n,s){if((0,x.DO)(t),Ot(r),(e=Ke(e)).length>255){const o=Math.ceil(2*n/8);e=s.create({dkLen:o}).update((0,x.AI)("H2C-OVERSIZE-DST-")).update(e).digest()}if(r>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:r}).update(t).update(gt(r,2)).update(e).update(gt(e.length,1)).digest()}(t,f,h,s,i);else{if("_internal_pass"!==c)throw new Error('expand must be "xmd" or "xof"');a=t}const d=new Array(e);for(let w=0;w<e;w++){const y=new Array(o);for(let B=0;B<o;B++){const O=l*(B+w*o),U=a.subarray(O,O+l);y[B]=F(qn(U),n)}d[w]=y}return d}const Tn=(0,x.AI)("HashToScalar-"),vt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Vn={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Zn=BigInt(0),je=BigInt(1),re=BigInt(2),ct=Et(vt.p,{sqrt:function kn(t){const e=vt.p,r=BigInt(3),n=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),c=BigInt(44),f=BigInt(88),u=t*t*t%e,l=u*u*t%e,h=nt(l,r,e)*l%e,a=nt(h,r,e)*l%e,d=nt(a,re,e)*u%e,w=nt(d,s,e)*d%e,y=nt(w,o,e)*w%e,B=nt(y,c,e)*y%e,O=nt(B,f,e)*B%e,U=nt(O,c,e)*y%e,p=nt(U,r,e)*l%e,T=nt(p,i,e)*w%e,V=nt(T,n,e)*u%e,$=nt(V,re,e);if(!ct.eql(ct.sqr($),t))throw new Error("Cannot find square root");return $}}),Zt=function Hn(t,e){const r=n=>On({...t,hash:n});return{...r(e),create:r}}({...vt,Fp:ct,lowS:!0,endo:Vn},Rt),Ge={};function kt(t,...e){let r=Ge[t];if(void 0===r){const n=Rt((0,x.AI)(t));r=(0,x.Id)(n,n),Ge[t]=r}return Rt((0,x.Id)(r,...e))}const se=t=>t.toBytes(!0).slice(1),_t=Zt.Point,oe=t=>t%re===Zn;function ie(t){const{Fn:e,BASE:r}=_t,n=bt(e,t),s=r.multiply(n);return{scalar:oe(s.y)?n:e.neg(n),bytes:se(s)}}function Ye(t){const e=ct;if(!e.isValidNot0(t))throw new Error("invalid x: Fail if x \u2265 p");const r=e.create(t*t),n=e.create(r*t+BigInt(7));let s=e.sqrt(n);oe(s)||(s=e.neg(s));const o=_t.fromAffine({x:t,y:s});return o.assertValidity(),o}const Ht=mt;function We(...t){return _t.Fn.create(Ht(kt("BIP0340/challenge",...t)))}function ze(t){return ie(t).bytes}function Dn(t,e,r=(0,x.po)(32)){const{Fn:n}=_t,s=K("message",t),{bytes:o,scalar:i}=ie(e),c=K("auxRand",r,32),f=n.toBytes(i^Ht(kt("BIP0340/aux",c))),u=kt("BIP0340/nonce",f,o,s),{bytes:l,scalar:h}=ie(u),a=We(l,o,s),d=new Uint8Array(64);if(d.set(l,0),d.set(n.toBytes(n.create(h+a*i)),32),!Pe(d,s,o))throw new Error("sign: Invalid signature produced");return d}function Pe(t,e,r){const{Fn:n,BASE:s}=_t,o=K("signature",t,64),i=K("message",e),c=K("publicKey",r,32);try{const f=Ye(Ht(c)),u=Ht(o.subarray(0,32));if(!jt(u,je,vt.p))return!1;const l=Ht(o.subarray(32,64));if(!jt(l,je,vt.n))return!1;const h=We(n.toBytes(u),se(f),i),a=s.multiplyUnsafe(l).add(f.multiplyUnsafe(n.neg(h))),{x:d,y:w}=a.toAffine();return!(a.is0()||!oe(w)||d!==u)}catch{return!1}}const Mn=(()=>{const r=(s=(0,x.po)(48))=>qe(s,vt.n);return{keygen:function n(s){const o=r(s);return{secretKey:o,publicKey:ze(o)}},getPublicKey:ze,sign:Dn,verify:Pe,Point:_t,utils:{randomSecretKey:r,randomPrivateKey:r,taggedHash:kt,lift_x:Ye,pointToBytes:se,numberToBytesBE:Nt,bytesToNumberBE:mt,mod:F},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})(),Kn=function Nn(t,e){const r=e.map(n=>Array.from(n).reverse());return(n,s)=>{const[o,i,c,f]=r.map(h=>h.reduce((a,d)=>t.add(t.mul(a,n),d))),[u,l]=Lt(t,[i,f],!0);return n=t.mul(o,u),s=t.mul(s,t.mul(c,l)),{x:n,y:s}}}(ct,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(e=>BigInt(e)))),jn=function pn(t,e){Ae(t);const{A:r,B:n,Z:s}=e;if(!t.isValid(r)||!t.isValid(n)||!t.isValid(s))throw new Error("mapToCurveSimpleSWU: invalid opts");const o=function En(t,e){const r=t.ORDER;let n=rt;for(let w=r-Y;w%ot===rt;w/=ot)n+=Y;const s=n,o=ot<<s-Y-Y,i=o*ot,c=(r-Y)/i,f=(c-Y)/ot,u=i-Y,l=o,h=t.pow(e,c),a=t.pow(e,(c+Y)/ot);let d=(w,y)=>{let B=h,O=t.pow(y,u),U=t.sqr(O);U=t.mul(U,y);let p=t.mul(w,U);p=t.pow(p,f),p=t.mul(p,O),O=t.mul(p,y),U=t.mul(p,w);let T=t.mul(U,O);p=t.pow(T,l);let V=t.eql(p,t.ONE);O=t.mul(U,a),p=t.mul(T,B),U=t.cmov(O,U,V),T=t.cmov(p,T,V);for(let $=s;$>Y;$--){let tt=$-ot;tt=ot<<tt-Y;let Z=t.pow(T,tt);const A=t.eql(Z,t.ONE);O=t.mul(U,B),B=t.mul(B,B),Z=t.mul(T,B),U=t.cmov(O,U,A),T=t.cmov(Z,T,A)}return{isValid:V,value:U}};if(t.ORDER%ee===Bt){const w=(t.ORDER-Bt)/ee,y=t.sqrt(t.neg(e));d=(B,O)=>{let U=t.sqr(O);const p=t.mul(B,O);U=t.mul(U,p);let T=t.pow(U,w);T=t.mul(T,p);const V=t.mul(T,y),$=t.mul(t.sqr(T),O),tt=t.eql($,B);return{isValid:tt,value:t.cmov(V,T,tt)}}}return d}(t,s);if(!t.isOdd)throw new Error("Field does not have .isOdd()");return i=>{let c,f,u,l,h,a,d,w;c=t.sqr(i),c=t.mul(c,s),f=t.sqr(c),f=t.add(f,c),u=t.add(f,t.ONE),u=t.mul(u,n),l=t.cmov(s,t.neg(f),!t.eql(f,t.ZERO)),l=t.mul(l,r),f=t.sqr(u),a=t.sqr(l),h=t.mul(a,r),f=t.add(f,h),f=t.mul(f,u),a=t.mul(a,l),h=t.mul(a,n),f=t.add(f,h),d=t.mul(c,u);const{isValid:y,value:B}=o(f,a);w=t.mul(c,i),w=t.mul(w,B),d=t.cmov(d,u,y),w=t.cmov(w,B,y);const O=t.isOdd(i)===t.isOdd(w);w=t.cmov(t.neg(w),w,O);const U=Lt(t,[l],!0)[0];return d=t.mul(d,U),{x:d,y:w}}}(ct,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:ct.create(BigInt("-11"))}),ce=function Ln(t,e,r){if("function"!=typeof e)throw new Error("mapToCurve() must be defined");function n(o){return t.fromAffine(e(o))}function s(o){const i=o.clearCofactor();return i.equals(t.ZERO)?t.ZERO:(i.assertValidity(),i)}return{defaults:r,hashToCurve(o,i){const f=ne(o,2,Object.assign({},r,i)),u=n(f[0]),l=n(f[1]);return s(u.add(l))},encodeToCurve:(o,i)=>s(n(ne(o,1,Object.assign({},r,r.encodeDST?{DST:r.encodeDST}:{},i))[0])),mapToCurve(o){if(!Array.isArray(o))throw new Error("expected array of bigints");for(const i of o)if("bigint"!=typeof i)throw new Error("expected array of bigints");return s(n(o))},hashToScalar:(o,i)=>ne(o,1,Object.assign({},r,{p:t.Fn.ORDER,m:1,DST:Tn},i))[0][0]}}(Zt.Point,t=>{const{x:e,y:r}=jn(ct.create(t[0]));return Kn(e,r)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:ct.ORDER,m:1,k:128,expand:"xmd",hash:Rt}),Gn=ce.hashToCurve,Yn=ce.encodeToCurve}}]);